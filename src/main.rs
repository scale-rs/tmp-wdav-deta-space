use askama::Template;
use const_format::formatcp;
use dav_server::{
    fakels::FakeLs, localfs::LocalFs, DavConfig, DavHandler, DavMethod, DavMethodSet,
};
use http::uri::Uri;
use std::fmt::Debug;
use std::fs::{self, DirEntry, ReadDir};
use std::net::{IpAddr, SocketAddr};
use std::{env, io, path::Path};
use warp::http::{self, HeaderValue, StatusCode};
use warp::{redirect, reject, reject::Reject, reject::Rejection, reply, Filter, Reply};

/// Environment variable name that contains the port number assigned by Deta.Space.
const ENV_PORT: &'static str = "PORT";
const DEFAULT_PORT: &'static str = "8080";

/// Environment variable name that contains private key ("data key", formerly known as "project
/// key", generated by Deta.Space. (See also
/// <https://deta.space/docs/en/build/fundamentals/data-storage#manual-setup>).
const ENV_DATA_KEY: &'static str = "DETA_PROJECT_KEY";

/// Environment variable name that contains "salt", so that users whom you give write hashes can't
/// brute-force your Deta.Space private key.
const ENV_SALT: &'static str = "SALT";

// Directory names here don't have a trailing slash.
//
// const TMP: &'static str = "/tmp"; // @TODO add if we use `const_format`
const DIRS: &'static str = "/tmp/wdav_dirs";

// Leading URL "segments" (top level directories). Warp requires them NOT to contain any slash.
const READ: &'static str = "read";
const WRITE: &'static str = "write";
const ADMIN: &'static str = "admin";
const ADD: &'static str = "add";

// Directories containing symlinks. These constants could use `const_format` crate. But that
// involves quote + syn = long build times. TODO reconsider because of Tokio, or don't use Tokio
// attrib. macro.
const SYMLINKS: &'static str = "/tmp/wdav_symlinks";
const SYMLINKS_WRITE: &'static str = formatcp!("{SYMLINKS}/{WRITE}");
const SYMLINKS_READ: &'static str = formatcp!("{SYMLINKS}/{READ}");

const CLEANUP_IN_PROGRESS: &'static str = formatcp!("{SYMLINKS}/CLEANUP_IN_PROGRESS");

fn dav_config(
    prefix_segment: impl core::fmt::Display,
    dir_path: impl AsRef<Path>,
    methods: DavMethodSet,
) -> DavConfig {
    // No symlinks by default. The following disables symlinks:
    //
    //let warp_dav = dav_server::warp::dav_dir(base, true, true);

    // LocalFs::new(...) enables symlinks. With symlinks allowed: Content of symlinked directories
    // IS served, but such directories themselves are not shown by default. That's documented, see
    // dav_server::DavConfig::hide_symlinks(...).
    //
    // That is excellent for our need-to-know-based ACL.
    //
    // In GNOME open the WebDAV directory with: nautilus dav://127.0.0.1:4201/subdir-here
    DavHandler::builder()
        .filesystem(LocalFs::new(dir_path, false, false, false))
        //--- @TODO SYMLINKS_READ to a param
        .locksystem(FakeLs::new())
        .autoindex(true) //@TODO
        .indexfile("index.html")
        .methods(methods)
        //.strip_prefix("/".to_owned() + prefix_segment)
        .strip_prefix(format!("/{}", prefix_segment))
}

#[derive(Debug)]
struct Rej<T>(T)
where
    T: Debug + Sized + Send + Sync;

unsafe impl<T> Send for Rej<T> where T: Debug + Sized + Send + Sync {}
unsafe impl<T> Sync for Rej<T> where T: Debug + Sized + Send + Sync {}
impl<T> Reject for Rej<T> where T: Debug + Sized + Send + Sync + 'static {}

fn redirect_see_other<L>(location: L) -> Result<impl Reply, Rejection>
where
    HeaderValue: TryFrom<L>,
    <HeaderValue as TryFrom<L>>::Error: Into<http::Error>,
{
    // Content-type', 'text/html')
    //warp::reply::with::headers(headers)
    Ok(warp::reply::with_status(
        warp::reply::with_header(warp::reply(), "Location:", location),
        StatusCode::SEE_OTHER,
    ))
    /*
    Ok(warp::reply::with_header(
        warp::reply::with_status(warp::reply(), StatusCode::SEE_OTHER),
        "Location:",
        location,
    ))
    */
}

#[derive(Template)]
#[template(path = "admin_list.html")]
struct AdminListTemplate {
    dirs: Vec<DirEntry>,
}

// Thanks to https://blog.logrocket.com/template-rendering-in-rust
type WebResult<T> = std::result::Result<T, Rejection>;

async fn admin_list() -> WebResult<impl Reply> {
    let dirs = fs::read_dir(DIRS).map_err(|e| reject::custom(Rej(e)))?;

    let mut dirs_vec = Vec::<DirEntry>::new();
    for entry in dirs {
        match entry {
            Ok(dir) => dirs_vec.push(dir),
            Err(err) => return Err(reject::custom(Rej(err))),
        }
    }

    let template = AdminListTemplate { dirs: dirs_vec };
    let res = template.render().map_err(|e| reject::custom(Rej(e)))?;
    Ok(reply::html(res))
}

async fn admin_add(dir_name: String) -> Result<impl Reply, Rejection> {
    let dir_result = fs::create_dir(format!("{DIRS}/{dir_name}"));
    if let Err(e) = dir_result {
        return Err(reject::custom(Rej(e)));
    }
    //redirect_see_other(format!("/{ADMIN}"))
    Ok(redirect::see_other(
        format!("/{ADMIN}").parse::<Uri>().expect("Admin UR"),
    ))
}

async fn admin_remove_write(dir_name: String) -> Result<impl Reply, Rejection> {
    let dir_result = fs::create_dir(format!("{DIRS}/{dir_name}"));
    if let Err(e) = dir_result {
        return Err(reject::custom(Rej(e)));
    }
    redirect_see_other(format!("/{ADMIN}"))
}

#[tokio::main]
async fn main() -> io::Result<()> {
    let port = env::var(ENV_PORT).unwrap_or(DEFAULT_PORT.to_string());
    let port = port.parse::<u16>().unwrap();

    let salt = env::var(ENV_SALT).expect("Requiring SALT env variable.");
    let data_key = env::var(ENV_DATA_KEY).expect("Requiring 'data key', formerly known as 'project key'. It should be passed automatically by Deta on both Deta platform and local `space dev`.");

    let ip: IpAddr = "127.0.0.1".parse().unwrap();
    let addr = SocketAddr::new(ip, port);

    fs::create_dir_all(DIRS)?;
    fs::create_dir_all(SYMLINKS)?;
    fs::create_dir_all(SYMLINKS_READ)?;
    fs::create_dir_all(SYMLINKS_WRITE)?;

    let dav_read_filter = {
        // DavMethodSet::add(&mut self, DavMethod) is ugly. And there is no direct method to
        // add/merge/union two instances of DavMethodSet. But, for now, the following:
        let mut read_only = DavMethodSet::HTTP_RO;
        read_only.add(DavMethod::PropFind);

        let dav_handler = dav_config(READ, SYMLINKS_READ, read_only).build_handler();
        dav_server::warp::dav_handler(dav_handler)
    };

    let dav_write_filter = {
        // The following is impractical/redundant, but it's currently the only portable/correct way.
        let mut read_write = DavMethodSet::WEBDAV_RW;
        // Based on source of DavMethodSet::HTTP_RW:
        read_write.add(DavMethod::Get);
        read_write.add(DavMethod::Head);
        read_write.add(DavMethod::Options);
        read_write.add(DavMethod::Put);

        let dav_handler = dav_config(WRITE, SYMLINKS_WRITE, read_write).build_handler();
        dav_server::warp::dav_handler(dav_handler)
    };

    let admin_list = warp::path(ADMIN)
        .and(warp::path::end())
        .and_then(admin_list);

    // HTTP POST with URL parameters is unusual, but easy to handle & test
    let admin_add = warp::post()
        .and(warp::body::content_length_limit(1024 * 16))
        .and(warp::path!("admin" / "add" / String))
        .and_then(admin_add);

    let routes = warp::any().and(
        admin_list
            .or(admin_add)
            .or(warp::path(READ).and(dav_read_filter))
            .or(warp::path(WRITE).and(dav_write_filter)),
    );

    println!("listening on {}.", addr);
    warp::serve(routes).run(addr).await;
    Ok(())
}
